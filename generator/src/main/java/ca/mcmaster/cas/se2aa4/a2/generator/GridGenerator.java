package ca.mcmaster.cas.se2aa4.a2.generator;

import java.util.ArrayList;
import java.util.List;

import ca.mcmaster.cas.se2aa4.a2.components.*;
import ca.mcmaster.cas.se2aa4.a2.mesh.Mesh;

import org.apache.logging.log4j.*;

/**
 * GridGenerator
 */
public class GridGenerator implements Generator {
    private static final Logger logger = LogManager.getLogger(GridGenerator.class);

    static final double TOP_X = 0, TOP_Y = 0;
    static final int MIN_SIDE_LENGTH = 20, DEFAULT_SIDE_LENGTH = 100;

    private int sideLength;

    public GridGenerator(int sideLength) {
        this.sideLength = Math.max(sideLength, MIN_SIDE_LENGTH);
        updateSideLength(sideLength, MIN_SIDE_LENGTH, "below", -1);
    }

    void updateSideLength(int givenValue, int defaultValue, String extremity, int compResult) {
        if (Integer.compare(givenValue, defaultValue) == compResult) {
            logger.warn(String.format("The interpreted value of '%1$s' was set %3$s the minimum value of %2$s for"
                    + " argument SIDE_LENGTH. Setting SIDE_LENGTH to default value %2$s", givenValue, defaultValue,
                    extremity));
            this.sideLength = defaultValue;
        } else {
            this.sideLength = givenValue;
        }
    }

    @Override
    public void generate(final Mesh mesh) {
        // This is to compromise a small mesh given, but the generator will create grids
        // of the given sideLength in other cases.
        updateSideLength(sideLength, mesh.getHeight(), "above", 1);
        updateSideLength(sideLength, mesh.getWidth(), "above", 1);
        // Round the increment to 2 decimal places (be sure of the the rounding)
        final double increment = Math.round((sideLength / 2.0) * 100) / 100.0;
        // Find the number of squares that at least partially fit inside the canvas
        // area, and calculate the centroid bounds
        final double bottomCentY = (Math.ceil(mesh.getHeight() / (sideLength + 0.0)) * sideLength) - increment;
        final double bottomCentX = (Math.ceil(mesh.getWidth() / (sideLength + 0.0)) * sideLength) - increment;
        final List<double[]> allCentroids = generateCentroids(increment, bottomCentX, bottomCentY);
        // Create a list of Polygons using the generateCentroids
        final List<Poly> allPolys = generatePolygons(allCentroids);
        // Create the vertices for all Polygons in the list in a radial order
        populateVertices(allPolys, increment);
        // Create the neighbours for all Polygons in the list
        populateNeighbours(allPolys, increment, bottomCentX, bottomCentY);
        // Add all components to the mesh from the generated polygons
        addAllComponents(mesh, allPolys);
    }

    /**
     * Adds all the necessary components generated by the polygon to the given mesh.
     *
     * @param mesh     the Mesh to add all components to.
     * @param polygons the list of Polygons from which all relevant components are
     *                 generated.
     */
    void addAllComponents(final Mesh mesh, final List<Poly> polygons) {
        Vert v;
        Seg s;
        List<double[]> vertices;
        for (Poly p : polygons) {
            vertices = p.getVertexList();
            // Add the first vertex of this polygon
            v = new Vertex(vertices.get(0)[0], vertices.get(0)[1]);
            mesh.addVert(v);
            // Add remaining vertices, and since they are ordered radially, they are
            // adjacent to the vertices before and after them.
            // As a result, a segment can be made with this vertex and the vertex before, so
            // add that as well.
            for (int i = 1; i < vertices.size(); i++) {
                v = new Vertex(vertices.get(i)[0], vertices.get(i)[1]);
                mesh.addVert(v);
                s = new Segment(vertices.get(i - 1)[0], vertices.get(i - 1)[1], vertices.get(i)[0], vertices.get(i)[1]);
                mesh.addSeg(s);
            }
            // Add the segment that connects the first vertex with the last one.
            // s = new Segment(vertices.get(0)[0], vertices.get(0)[1],
            // vertices.get(vertices.size() - 1)[0],
            // vertices.get(vertices.size() - 1)[1]);
            // mesh.addSeg(s);
            mesh.addPoly(p);
        }
    }

    /**
     * Populates all the valid neighbouring centroids for the current polygon.
     *
     * @param polygons    the list of polygons whose neighbours need to be
     *                    populated.
     * @param increment   the shortest distance between the edge of a polygon and
     *                    its
     *                    centroid.
     * @param bottomCentX the rightmost centroid location bound for a neighbour.
     * @param bottomCentY the bottommost centroid location bound for a neighbour.
     */
    void populateNeighbours(final List<Poly> polygons, final double increment, final double bottomCentX,
            final double bottomCentY) {
        List<double[]> neighbourCentroids;
        double x, y;
        for (final Poly poly : polygons) {
            neighbourCentroids = new ArrayList<>();
            // Use math to calculate each neighbouring centroid's index
            for (int i = -1; i < 2; i++) {
                for (int j = -1; j < 2; j++) {
                    // Calculate the current centroid index
                    x = poly.getCentroidX() + (2 * i * increment);
                    y = poly.getCentroidY() + (2 * j * increment);
                    // Add the calculated centroid position iff it is in the bounds and not the
                    // current centroid
                    if (x >= TOP_X && y >= TOP_Y && (x != poly.getCentroidX() || y != poly.getCentroidY())
                            && x <= bottomCentX && y <= bottomCentY) {
                        neighbourCentroids.add(new double[] { x, y });
                    }
                }
            }
            poly.setNeighbours(neighbourCentroids);
        }
    }

    /**
     * Populates all the valid vertices for the current polygon.
     *
     * @param polygons  the list of polygons whose neighbours need to be populated.
     * @param increment the shortest distance between the edge of a polygon and its
     *                  centroid.
     */
    void populateVertices(final List<Poly> polygons, final double increment) {
        List<double[]> vertices;
        for (final Poly polygon : polygons) {
            vertices = new ArrayList<>();
            vertices.add(new double[] { polygon.getCentroidX() + increment, polygon.getCentroidY() - increment });
            vertices.add(new double[] { polygon.getCentroidX() - increment, polygon.getCentroidY() - increment });
            vertices.add(new double[] { polygon.getCentroidX() - increment, polygon.getCentroidY() + increment });
            vertices.add(new double[] { polygon.getCentroidX() + increment, polygon.getCentroidY() + increment });
            vertices.add(new double[] { polygon.getCentroidX() + increment, polygon.getCentroidY() - increment });
            polygon.setVertices(vertices);
        }
    }

    /**
     * Generates the list of Polygons to be contained in the given mesh based on
     * their centroid locations.
     *
     * @param centroids the list containing the centroid for each Polygon.
     * @return a list of Polygons with their centroids populated.
     */
    private List<Poly> generatePolygons(final List<double[]> centroids) {
        final List<Poly> polygons = new ArrayList<>();
        Polygon p;
        for (final double[] centroid : centroids) {
            p = new Polygon(centroid[0], centroid[1]);
            polygons.add(p);
        }
        return polygons;
    }

    /**
     * Generates a list of XY-pairs with all of the centroids in the current mesh.
     *
     * @param increment   the shortest distance between the edge and the centroid
     *                    of the square.
     * @param bottomCentX The last x-value for a valid centroid in case of
     *                    overflow.
     * @param bottomCentY The last y-value for a valid centroid in case of
     *                    overflow.
     * @return a list of XY-pairs stored as double[] representing the coordinates of
     *         each centroid.
     */
    private List<double[]> generateCentroids(final double increment, final double bottomCentX,
            final double bottomCentY) {
        final List<double[]> centroids = new ArrayList<>();
        for (double x = TOP_X + increment; x <= bottomCentX; x += 2 * increment) {
            for (double y = TOP_Y + increment; y <= bottomCentY; y += 2 * increment) {
                centroids.add(new double[] { x, y });
            }
        }
        return centroids;
    }

}